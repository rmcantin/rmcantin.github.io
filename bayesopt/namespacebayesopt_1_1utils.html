<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>BayesOpt: bayesopt::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BayesOpt
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacebayesopt_1_1utils.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bayesopt::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Extra utils: math functions, ublas helpers, etc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayesopt_1_1utils_1_1BoundingBox.html">BoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a bounding box or axis-alligned bound constraints.  <a href="classbayesopt_1_1utils_1_1BoundingBox.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayesopt_1_1utils_1_1CUnique.html">CUnique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class to generate sequences of unique numbers.  <a href="classbayesopt_1_1utils_1_1CUnique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayesopt_1_1utils_1_1DisplayProblem1D.html">DisplayProblem1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbayesopt_1_1utils_1_1DisplayProblem2D.html">DisplayProblem2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a260aa91f2f4776dbe22f2885f43dff64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a260aa91f2f4776dbe22f2885f43dff64"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RunningStatus</b> { <b>RUN</b>, 
<b>STEP</b>, 
<b>STOP</b>, 
<b>NOT_READY</b>
 }</td></tr>
<tr class="separator:a260aa91f2f4776dbe22f2885f43dff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a94c760fbe1c01e530a9094b4e01b0548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c760fbe1c01e530a9094b4e01b0548"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>loadData</b> (std::string filename, vecOfvec &amp;xx, vectord &amp;yy)</td></tr>
<tr class="separator:a94c760fbe1c01e530a9094b4e01b0548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832c007fb3952b7415a85057de3796ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a832c007fb3952b7415a85057de3796ff"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dumpData</b> (std::string filename, const vecOfvec &amp;xx, const vectord &amp;yy)</td></tr>
<tr class="separator:a832c007fb3952b7415a85057de3796ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9396d731670b4b10d57dc2a35a81b220"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a9396d731670b4b10d57dc2a35a81b220">savePoint</a> (std::string filename, const vectord &amp;xx, const double &amp;yy)</td></tr>
<tr class="memdesc:a9396d731670b4b10d57dc2a35a81b220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slow but safe function to dump data point by point.  <a href="#a9396d731670b4b10d57dc2a35a81b220">More...</a><br /></td></tr>
<tr class="separator:a9396d731670b4b10d57dc2a35a81b220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a6b702db24b428fe22220d22260118"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#ab3a6b702db24b428fe22220d22260118">savePoint</a> (std::ofstream &amp;file, const vectord &amp;xx, const double &amp;yy)</td></tr>
<tr class="memdesc:ab3a6b702db24b428fe22220d22260118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast way to dump data point by point.  <a href="#ab3a6b702db24b428fe22220d22260118">More...</a><br /></td></tr>
<tr class="separator:ab3a6b702db24b428fe22220d22260118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0da1881a91eb8260a96769828723edc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0da1881a91eb8260a96769828723edc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deepenGrid</b> (size_t comp, const vectori ndivs, vectord &amp;x, vecOfvec &amp;result)</td></tr>
<tr class="separator:af0da1881a91eb8260a96769828723edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c69f1995c539873221b484427cc6eb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c69f1995c539873221b484427cc6eb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>buildGrid</b> (const vectori &amp;dims, vecOfvec &amp;result)</td></tr>
<tr class="separator:a1c69f1995c539873221b484427cc6eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e8fcdd5b7b97f4de8c860683d2b487"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a05e8fcdd5b7b97f4de8c860683d2b487">return_index_vector</a> (size_t n)</td></tr>
<tr class="memdesc:a05e8fcdd5b7b97f4de8c860683d2b487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector of indexes (1..n)  <a href="#a05e8fcdd5b7b97f4de8c860683d2b487">More...</a><br /></td></tr>
<tr class="separator:a05e8fcdd5b7b97f4de8c860683d2b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25e4b3fbdf7a70d6c8a488fa355d354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#ae25e4b3fbdf7a70d6c8a488fa355d354">return_index_vector</a> (int a, size_t n)</td></tr>
<tr class="memdesc:ae25e4b3fbdf7a70d6c8a488fa355d354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a vector of indexes starting at A and size_t n.  <a href="#ae25e4b3fbdf7a70d6c8a488fa355d354">More...</a><br /></td></tr>
<tr class="separator:ae25e4b3fbdf7a70d6c8a488fa355d354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b74cf4e6af26acec59618da88f3b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#af9b74cf4e6af26acec59618da88f3b46">modify_index_vector</a> (std::vector&lt; int &gt; &amp;arr)</td></tr>
<tr class="memdesc:af9b74cf4e6af26acec59618da88f3b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a vector of indexes (0..n)  <a href="#af9b74cf4e6af26acec59618da88f3b46">More...</a><br /></td></tr>
<tr class="separator:af9b74cf4e6af26acec59618da88f3b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc701508c784a267b7996c859e9f708c"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:abc701508c784a267b7996c859e9f708c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#abc701508c784a267b7996c859e9f708c">samplePoints</a> (M &amp;xPoints, int method, randEngine &amp;mtRandom)</td></tr>
<tr class="memdesc:abc701508c784a267b7996c859e9f708c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the sampling method.  <a href="#abc701508c784a267b7996c859e9f708c">More...</a><br /></td></tr>
<tr class="separator:abc701508c784a267b7996c859e9f708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d81cd4219c404f9680498537ef40e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a17d81cd4219c404f9680498537ef40e4"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:a17d81cd4219c404f9680498537ef40e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a17d81cd4219c404f9680498537ef40e4">lhs</a> (M &amp;Result, randEngine &amp;mtRandom)</td></tr>
<tr class="memdesc:a17d81cd4219c404f9680498537ef40e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Latin hypercube sampling It is used to generate a uniform Latin hypercube. <br /></td></tr>
<tr class="separator:a17d81cd4219c404f9680498537ef40e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30e8a315809c8aab33c89fe268d8927"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:ae30e8a315809c8aab33c89fe268d8927"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#ae30e8a315809c8aab33c89fe268d8927">uniformSampling</a> (M &amp;Result, randEngine &amp;mtRandom)</td></tr>
<tr class="memdesc:ae30e8a315809c8aab33c89fe268d8927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypercube sampling based on Sobol sequences It uses the external Sobol library.  <a href="#ae30e8a315809c8aab33c89fe268d8927">More...</a><br /></td></tr>
<tr class="separator:ae30e8a315809c8aab33c89fe268d8927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb7c49aa7c462b801c367bc5973228"><td class="memTemplParams" colspan="2">template&lt;class D &gt; </td></tr>
<tr class="memitem:a1dbb7c49aa7c462b801c367bc5973228"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a1dbb7c49aa7c462b801c367bc5973228">randomPerms</a> (D &amp;arr, randEngine &amp;mtRandom)</td></tr>
<tr class="memdesc:a1dbb7c49aa7c462b801c367bc5973228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify an array using ramdom permutations.  <a href="#a1dbb7c49aa7c462b801c367bc5973228">More...</a><br /></td></tr>
<tr class="separator:a1dbb7c49aa7c462b801c367bc5973228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73863e3ef61b287abde2194ff73ef3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#af73863e3ef61b287abde2194ff73ef3a">parseExpresion</a> (std::string input, std::string &amp;parent, std::string &amp;child1, std::string &amp;child2)</td></tr>
<tr class="memdesc:af73863e3ef61b287abde2194ff73ef3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse expresions of the form Parent(Child1, Child2).  <a href="#af73863e3ef61b287abde2194ff73ef3a">More...</a><br /></td></tr>
<tr class="separator:af73863e3ef61b287abde2194ff73ef3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef08e0bc6685af7d45c1c9689f3503aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#aef08e0bc6685af7d45c1c9689f3503aa">parseExpresion</a> (std::string input, std::string &amp;parent, std::vector&lt; std::string &gt; &amp;childs)</td></tr>
<tr class="memdesc:aef08e0bc6685af7d45c1c9689f3503aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse expresions of the form Parent(Child1, ...  <a href="#aef08e0bc6685af7d45c1c9689f3503aa">More...</a><br /></td></tr>
<tr class="separator:aef08e0bc6685af7d45c1c9689f3503aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f946bc4451d0fbe2be4b93d72764c46"><td class="memTemplParams" colspan="2">template&lt;class MATRIX , class TRIA &gt; </td></tr>
<tr class="memitem:a2f946bc4451d0fbe2be4b93d72764c46"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a2f946bc4451d0fbe2be4b93d72764c46">cholesky_decompose</a> (const MATRIX &amp;A, TRIA &amp;L)</td></tr>
<tr class="memdesc:a2f946bc4451d0fbe2be4b93d72764c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">decompose the symmetric positive definit matrix A into product L L^T.  <a href="#a2f946bc4451d0fbe2be4b93d72764c46">More...</a><br /></td></tr>
<tr class="separator:a2f946bc4451d0fbe2be4b93d72764c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af029756cd602ef423db1a3436af523de"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:af029756cd602ef423db1a3436af523de"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#af029756cd602ef423db1a3436af523de">cholesky_decompose</a> (MATRIX &amp;A)</td></tr>
<tr class="memdesc:af029756cd602ef423db1a3436af523de"><td class="mdescLeft">&#160;</td><td class="mdescRight">decompose the symmetric positive definit matrix A into product L L^T.  <a href="#af029756cd602ef423db1a3436af523de">More...</a><br /></td></tr>
<tr class="separator:af029756cd602ef423db1a3436af523de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b8988af0d128a800d152b70e81a8c6"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a62b8988af0d128a800d152b70e81a8c6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a62b8988af0d128a800d152b70e81a8c6">incomplete_cholesky_decompose</a> (MATRIX &amp;A)</td></tr>
<tr class="memdesc:a62b8988af0d128a800d152b70e81a8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">decompose the symmetric positive definit matrix A into product L L^T.  <a href="#a62b8988af0d128a800d152b70e81a8c6">More...</a><br /></td></tr>
<tr class="separator:a62b8988af0d128a800d152b70e81a8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd0cbab67d8a948ba172896945cc1db"><td class="memTemplParams" colspan="2">template&lt;class TRIA , class MATRIX &gt; </td></tr>
<tr class="memitem:a1fd0cbab67d8a948ba172896945cc1db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a1fd0cbab67d8a948ba172896945cc1db">cholesky_solve</a> (const TRIA &amp;L, MATRIX &amp;x, ublas::lower)</td></tr>
<tr class="memdesc:a1fd0cbab67d8a948ba172896945cc1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve system L L^T x = b inplace  <a href="#a1fd0cbab67d8a948ba172896945cc1db">More...</a><br /></td></tr>
<tr class="separator:a1fd0cbab67d8a948ba172896945cc1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb089d0c8ff6ab04048388835bfe0b89"><td class="memTemplParams" colspan="2">template&lt;class Min , class Mout &gt; </td></tr>
<tr class="memitem:acb089d0c8ff6ab04048388835bfe0b89"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#acb089d0c8ff6ab04048388835bfe0b89">inverse_cholesky</a> (const Min &amp;M, Mout &amp;inverse)</td></tr>
<tr class="memdesc:acb089d0c8ff6ab04048388835bfe0b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse matrix of a symmetric positive definite matrix.  <a href="#acb089d0c8ff6ab04048388835bfe0b89">More...</a><br /></td></tr>
<tr class="separator:acb089d0c8ff6ab04048388835bfe0b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84a30c1793f9680f3dbef67ae9caff7"><td class="memTemplParams" colspan="2">template&lt;class TRIA , class VECTOR &gt; </td></tr>
<tr class="memitem:aa84a30c1793f9680f3dbef67ae9caff7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#aa84a30c1793f9680f3dbef67ae9caff7">cholesky_add_row</a> (TRIA &amp;L, const VECTOR &amp;v)</td></tr>
<tr class="memdesc:aa84a30c1793f9680f3dbef67ae9caff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">decompose the symmetric positive definit matrix A into product L L^T.  <a href="#aa84a30c1793f9680f3dbef67ae9caff7">More...</a><br /></td></tr>
<tr class="separator:aa84a30c1793f9680f3dbef67ae9caff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1018b9617a8e1cc6d04d8abc18ef4089"><td class="memTemplParams" colspan="2">template&lt;class v1 , class v2 &gt; </td></tr>
<tr class="memitem:a1018b9617a8e1cc6d04d8abc18ef4089"><td class="memTemplItemLeft" align="right" valign="top">v1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#a1018b9617a8e1cc6d04d8abc18ef4089">ublas_elementwise_prod</a> (const v1 &amp;a, const v2 &amp;b)</td></tr>
<tr class="memdesc:a1018b9617a8e1cc6d04d8abc18ef4089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the elementwise product of two vectors or matrices.  <a href="#a1018b9617a8e1cc6d04d8abc18ef4089">More...</a><br /></td></tr>
<tr class="separator:a1018b9617a8e1cc6d04d8abc18ef4089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecefc4cb993d5ab50a82c957a132f28f"><td class="memTemplParams" colspan="2">template&lt;class v1 , class v2 &gt; </td></tr>
<tr class="memitem:aecefc4cb993d5ab50a82c957a132f28f"><td class="memTemplItemLeft" align="right" valign="top">v1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebayesopt_1_1utils.html#aecefc4cb993d5ab50a82c957a132f28f">ublas_elementwise_div</a> (const v1 &amp;a, const v2 &amp;b)</td></tr>
<tr class="memdesc:aecefc4cb993d5ab50a82c957a132f28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the elementwise division of two vectors or matrices.  <a href="#aecefc4cb993d5ab50a82c957a132f28f">More...</a><br /></td></tr>
<tr class="separator:aecefc4cb993d5ab50a82c957a132f28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf716e9477107fbc0751e13abd13f39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf716e9477107fbc0751e13abd13f39"></a>
boost::numeric::ublas::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>array2vector</b> (const double array[], const size_t n)</td></tr>
<tr class="separator:abcf716e9477107fbc0751e13abd13f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0f1e9bdb749d309afb728d2b1e83a8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0a0f1e9bdb749d309afb728d2b1e83a8"></a>
template&lt;class V , class D &gt; </td></tr>
<tr class="memitem:a0a0f1e9bdb749d309afb728d2b1e83a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>append</b> (V &amp;vect, D element)</td></tr>
<tr class="separator:a0a0f1e9bdb749d309afb728d2b1e83a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7360d202ae3c0d324bb6d10fc7777a08"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7360d202ae3c0d324bb6d10fc7777a08"></a>
template&lt;class V , class I &gt; </td></tr>
<tr class="memitem:a7360d202ae3c0d324bb6d10fc7777a08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase</b> (V &amp;vect, I begin)</td></tr>
<tr class="separator:a7360d202ae3c0d324bb6d10fc7777a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a122aaf17d577268432b971882debb4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a122aaf17d577268432b971882debb4"></a>
template&lt;class M &gt; </td></tr>
<tr class="memitem:a4a122aaf17d577268432b971882debb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_column</b> (M &amp;mat, size_t pos)</td></tr>
<tr class="separator:a4a122aaf17d577268432b971882debb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac418ae67b5d19b5c45697ec375da2a4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac418ae67b5d19b5c45697ec375da2a4c"></a>
template&lt;class M , class V &gt; </td></tr>
<tr class="memitem:ac418ae67b5d19b5c45697ec375da2a4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_to_diagonal</b> (M &amp;mat, const V &amp;vec)</td></tr>
<tr class="separator:ac418ae67b5d19b5c45697ec375da2a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b7a1990f2cb74e39569f6cfb4307e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5b7a1990f2cb74e39569f6cfb4307e1"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:ad5b7a1990f2cb74e39569f6cfb4307e1"><td class="memTemplItemLeft" align="right" valign="top">E::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (const E &amp;A)</td></tr>
<tr class="separator:ad5b7a1990f2cb74e39569f6cfb4307e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2073c73e3f66ad4c50d73224eb617d9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2073c73e3f66ad4c50d73224eb617d9c"></a>
template&lt;class E &gt; </td></tr>
<tr class="memitem:a2073c73e3f66ad4c50d73224eb617d9c"><td class="memTemplItemLeft" align="right" valign="top">E::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>log_trace</b> (const E &amp;A)</td></tr>
<tr class="separator:a2073c73e3f66ad4c50d73224eb617d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97211a61996c2446def0aba3eebc2cc2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97211a61996c2446def0aba3eebc2cc2"></a>
template&lt;class E1 , class E2 &gt; </td></tr>
<tr class="memitem:a97211a61996c2446def0aba3eebc2cc2"><td class="memTemplItemLeft" align="right" valign="top">E1::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace_prod</b> (const E1 &amp;A, const E2 &amp;B)</td></tr>
<tr class="separator:a97211a61996c2446def0aba3eebc2cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Extra utils: math functions, ublas helpers, etc. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa84a30c1793f9680f3dbef67ae9caff7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TRIA , class VECTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::cholesky_add_row </td>
          <td>(</td>
          <td class="paramtype">TRIA &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VECTOR &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decompose the symmetric positive definit matrix A into product L L^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MATRIX</td><td>type of input matrix </td></tr>
    <tr><td class="paramname">TRIA</td><td>type of lower triangular output matrix </td></tr>
    <tr><td class="paramname">A</td><td>square symmetric positive definite input matrix (only the lower triangle is accessed) </td></tr>
    <tr><td class="paramname">L</td><td>lower triangular output matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ublas__cholesky_8hpp_source.html#l00264">264</a> of file <a class="el" href="ublas__cholesky_8hpp_source.html">ublas_cholesky.hpp</a>.</p>

<p>Referenced by <a class="el" href="kernelregressor_8hpp_source.html#l00206">bayesopt::KernelRegressor::addNewPointToCholesky()</a>, and <a class="el" href="kernelregressor_8cpp_source.html#l00052">bayesopt::KernelRegressor::updateSurrogateModel()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f946bc4451d0fbe2be4b93d72764c46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX , class TRIA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t bayesopt::utils::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TRIA &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decompose the symmetric positive definit matrix A into product L L^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MATRIX</td><td>type of input matrix </td></tr>
    <tr><td class="paramname">TRIA</td><td>type of lower triangular output matrix </td></tr>
    <tr><td class="paramname">A</td><td>square symmetric positive definite input matrix (only the lower triangle is accessed) </td></tr>
    <tr><td class="paramname">L</td><td>lower triangular output matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if decompositon fails (the value ist 1 + the numer of the failing row) </dd></dl>

<p>Definition at line <a class="el" href="ublas__cholesky_8hpp_source.html#l00057">57</a> of file <a class="el" href="ublas__cholesky_8hpp_source.html">ublas_cholesky.hpp</a>.</p>

<p>Referenced by <a class="el" href="kernelregressor_8cpp_source.html#l00062">bayesopt::KernelRegressor::computeCholeskyCorrelation()</a>, <a class="el" href="ublas__cholesky_8hpp_source.html#l00240">inverse_cholesky()</a>, <a class="el" href="gaussian__process__normal_8cpp_source.html#l00093">bayesopt::GaussianProcessNormal::negativeLogLikelihood()</a>, <a class="el" href="student__t__process__nig_8cpp_source.html#l00091">bayesopt::StudentTProcessNIG::negativeLogLikelihood()</a>, <a class="el" href="gaussian__process_8cpp_source.html#l00054">bayesopt::GaussianProcess::negativeLogLikelihood()</a>, <a class="el" href="gaussian__process__hierarchical_8cpp_source.html#l00037">bayesopt::HierarchicalGaussianProcess::negativeTotalLogLikelihood()</a>, <a class="el" href="gaussian__process__normal_8cpp_source.html#l00116">bayesopt::GaussianProcessNormal::precomputePrediction()</a>, <a class="el" href="student__t__process__jef_8cpp_source.html#l00080">bayesopt::StudentTProcessJeffreys::precomputePrediction()</a>, <a class="el" href="student__t__process__nig_8cpp_source.html#l00117">bayesopt::StudentTProcessNIG::precomputePrediction()</a>, and <a class="el" href="gaussian__process__ml_8cpp_source.html#l00078">bayesopt::GaussianProcessML::precomputePrediction()</a>.</p>

</div>
</div>
<a class="anchor" id="af029756cd602ef423db1a3436af523de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t bayesopt::utils::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decompose the symmetric positive definit matrix A into product L L^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MATRIX</td><td>type of matrix A </td></tr>
    <tr><td class="paramname">A</td><td>input: square symmetric positive definite matrix (only the lower triangle is accessed) </td></tr>
    <tr><td class="paramname">A</td><td>output: the lower triangle of A is replaced by the cholesky factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if decompositon fails (the value ist 1 + the numer of the failing row) </dd></dl>

<p>Definition at line <a class="el" href="ublas__cholesky_8hpp_source.html#l00099">99</a> of file <a class="el" href="ublas__cholesky_8hpp_source.html">ublas_cholesky.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1fd0cbab67d8a948ba172896945cc1db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TRIA , class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::cholesky_solve </td>
          <td>(</td>
          <td class="paramtype">const TRIA &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::lower&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solve system L L^T x = b inplace </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>a triangular matrix </td></tr>
    <tr><td class="paramname">x</td><td>input: right hand side b; output: solution x </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ublas__cholesky_8hpp_source.html#l00222">222</a> of file <a class="el" href="ublas__cholesky_8hpp_source.html">ublas_cholesky.hpp</a>.</p>

<p>Referenced by <a class="el" href="ublas__cholesky_8hpp_source.html#l00240">inverse_cholesky()</a>, <a class="el" href="gaussian__process__hierarchical_8cpp_source.html#l00037">bayesopt::HierarchicalGaussianProcess::negativeTotalLogLikelihood()</a>, <a class="el" href="gaussian__process__normal_8cpp_source.html#l00116">bayesopt::GaussianProcessNormal::precomputePrediction()</a>, <a class="el" href="student__t__process__jef_8cpp_source.html#l00080">bayesopt::StudentTProcessJeffreys::precomputePrediction()</a>, <a class="el" href="student__t__process__nig_8cpp_source.html#l00117">bayesopt::StudentTProcessNIG::precomputePrediction()</a>, and <a class="el" href="gaussian__process__ml_8cpp_source.html#l00078">bayesopt::GaussianProcessML::precomputePrediction()</a>.</p>

</div>
</div>
<a class="anchor" id="a62b8988af0d128a800d152b70e81a8c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t bayesopt::utils::incomplete_cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>decompose the symmetric positive definit matrix A into product L L^T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MATRIX</td><td>type of matrix A </td></tr>
    <tr><td class="paramname">A</td><td>input: square symmetric positive definite matrix (only the lower triangle is accessed) </td></tr>
    <tr><td class="paramname">A</td><td>output: the lower triangle of A is replaced by the cholesky factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if decompositon fails (the value ist 1 + the numer of the failing row) </dd></dl>

<p>Definition at line <a class="el" href="ublas__cholesky_8hpp_source.html#l00175">175</a> of file <a class="el" href="ublas__cholesky_8hpp_source.html">ublas_cholesky.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb089d0c8ff6ab04048388835bfe0b89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Min , class Mout &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t bayesopt::utils::inverse_cholesky </td>
          <td>(</td>
          <td class="paramtype">const Min &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mout &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse matrix of a symmetric positive definite matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>original matrix </td></tr>
    <tr><td class="paramname">inverse</td><td>inverse of M </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nonzero if decompositon fails (the value ist 1 + the numer of the failing row) </dd></dl>

<p>Definition at line <a class="el" href="ublas__cholesky_8hpp_source.html#l00240">240</a> of file <a class="el" href="ublas__cholesky_8hpp_source.html">ublas_cholesky.hpp</a>.</p>

<p>References <a class="el" href="ublas__cholesky_8hpp_source.html#l00057">cholesky_decompose()</a>, and <a class="el" href="ublas__cholesky_8hpp_source.html#l00222">cholesky_solve()</a>.</p>

</div>
</div>
<a class="anchor" id="af9b74cf4e6af26acec59618da88f3b46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::modify_index_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify a vector of indexes (0..n) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>vector </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="indexvector_8hpp_source.html#l00077">77</a> of file <a class="el" href="indexvector_8hpp_source.html">indexvector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af73863e3ef61b287abde2194ff73ef3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::parseExpresion </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>child1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>child2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse expresions of the form Parent(Child1, Child2). </p>
<p>The "childs" can also be expressions of the same type. </p>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00034">34</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

<p>Referenced by <a class="el" href="kernel__functors_8cpp_source.html#l00087">bayesopt::KernelFactory::create()</a>, <a class="el" href="criteria__functors_8cpp_source.html#l00081">bayesopt::CriteriaFactory::create()</a>, and <a class="el" href="mean__functors_8cpp_source.html#l00031">bayesopt::MeanFactory::create()</a>.</p>

</div>
</div>
<a class="anchor" id="aef08e0bc6685af7d45c1c9689f3503aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::parseExpresion </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>childs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse expresions of the form Parent(Child1, ... </p>
<p>,ChildN). The "childs" can also be expressions of the same type. </p>

<p>Definition at line <a class="el" href="parser_8cpp_source.html#l00069">69</a> of file <a class="el" href="parser_8cpp_source.html">parser.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1dbb7c49aa7c462b801c367bc5973228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::randomPerms </td>
          <td>(</td>
          <td class="paramtype">D &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">randEngine &amp;&#160;</td>
          <td class="paramname"><em>mtRandom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify an array using ramdom permutations. </p>
<p>It is used to generate a uniform Latin hypercube. Equivalent to std::random_shuffle but using boost::random </p>

<p>Definition at line <a class="el" href="lhs_8hpp_source.html#l00080">80</a> of file <a class="el" href="lhs_8hpp_source.html">lhs.hpp</a>.</p>

<p>Referenced by <a class="el" href="lhs_8hpp_source.html#l00091">lhs()</a>, and <a class="el" href="bayesoptdisc_8cpp_source.html#l00099">bayesopt::DiscreteModel::sampleInitialPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a05e8fcdd5b7b97f4de8c860683d2b487"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; bayesopt::utils::return_index_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector of indexes (1..n) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>vector size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index vector </dd></dl>

<p>Definition at line <a class="el" href="indexvector_8hpp_source.html#l00050">50</a> of file <a class="el" href="indexvector_8hpp_source.html">indexvector.hpp</a>.</p>

<p>Referenced by <a class="el" href="lhs_8hpp_source.html#l00091">lhs()</a>.</p>

</div>
</div>
<a class="anchor" id="ae25e4b3fbdf7a70d6c8a488fa355d354"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; bayesopt::utils::return_index_vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a vector of indexes starting at A and size_t n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>starting point </td></tr>
    <tr><td class="paramname">n</td><td>vector size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index vector </dd></dl>

<p>Definition at line <a class="el" href="indexvector_8hpp_source.html#l00064">64</a> of file <a class="el" href="indexvector_8hpp_source.html">indexvector.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc701508c784a267b7996c859e9f708c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::samplePoints </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>xPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">randEngine &amp;&#160;</td>
          <td class="paramname"><em>mtRandom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the sampling method. </p>

<p>Definition at line <a class="el" href="lhs_8hpp_source.html#l00141">141</a> of file <a class="el" href="lhs_8hpp_source.html">lhs.hpp</a>.</p>

<p>References <a class="el" href="lhs_8hpp_source.html#l00091">lhs()</a>, and <a class="el" href="lhs_8hpp_source.html#l00126">uniformSampling()</a>.</p>

<p>Referenced by <a class="el" href="bayesoptcont_8cpp_source.html#l00160">bayesopt::ContinuousModel::sampleInitialPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a9396d731670b4b10d57dc2a35a81b220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bayesopt::utils::savePoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vectord &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>yy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slow but safe function to dump data point by point. </p>
<p>Opens and closes the file every time. </p>

<p>Definition at line <a class="el" href="filedb_8cpp_source.html#l00082">82</a> of file <a class="el" href="filedb_8cpp_source.html">filedb.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab3a6b702db24b428fe22220d22260118"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bayesopt::utils::savePoint </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vectord &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>yy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast way to dump data point by point. </p>
<p>Assumes that the file is already openned and ready to append. </p>

<p>Definition at line <a class="el" href="filedb_8cpp_source.html#l00103">103</a> of file <a class="el" href="filedb_8cpp_source.html">filedb.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aecefc4cb993d5ab50a82c957a132f28f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class v1 , class v2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">v1 bayesopt::utils::ublas_elementwise_div </td>
          <td>(</td>
          <td class="paramtype">const v1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const v2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the elementwise division of two vectors or matrices. </p>
<p>c_i = a_i / b_i </p>

<p>Definition at line <a class="el" href="ublas__elementwise_8hpp_source.html#l00053">53</a> of file <a class="el" href="ublas__elementwise_8hpp_source.html">ublas_elementwise.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1018b9617a8e1cc6d04d8abc18ef4089"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class v1 , class v2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">v1 bayesopt::utils::ublas_elementwise_prod </td>
          <td>(</td>
          <td class="paramtype">const v1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const v2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the elementwise product of two vectors or matrices. </p>
<p>c_i = a_i * b_i </p>

<p>Definition at line <a class="el" href="ublas__elementwise_8hpp_source.html#l00040">40</a> of file <a class="el" href="ublas__elementwise_8hpp_source.html">ublas_elementwise.hpp</a>.</p>

<p>Referenced by <a class="el" href="gaussian__process__normal_8cpp_source.html#l00116">bayesopt::GaussianProcessNormal::precomputePrediction()</a>, and <a class="el" href="student__t__process__nig_8cpp_source.html#l00117">bayesopt::StudentTProcessNIG::precomputePrediction()</a>.</p>

</div>
</div>
<a class="anchor" id="ae30e8a315809c8aab33c89fe268d8927"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bayesopt::utils::uniformSampling </td>
          <td>(</td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>Result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">randEngine &amp;&#160;</td>
          <td class="paramname"><em>mtRandom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hypercube sampling based on Sobol sequences It uses the external Sobol library. </p>
<p>Thus it do not depend on boost random.Uniform hypercube sampling It is used to generate a set of uniformly distributed samples in hypercube </p>

<p>Definition at line <a class="el" href="lhs_8hpp_source.html#l00126">126</a> of file <a class="el" href="lhs_8hpp_source.html">lhs.hpp</a>.</p>

<p>Referenced by <a class="el" href="lhs_8hpp_source.html#l00141">samplePoints()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebayesopt.html">bayesopt</a></li><li class="navelem"><a class="el" href="namespacebayesopt_1_1utils.html">utils</a></li>
    <li class="footer">Generated on Wed Feb 25 2015 01:47:52 for BayesOpt by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
